import cv2
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw
from math import ceil, sqrt
import random
import time


# determine constants
GRID_SIZE = 10
CHROMOSOMES_NUMBER = 50
MUTATION_RATE = 0.5
CROSSOVER_RATE = 0.3


# fitness calculating function
def fitness(chromosome, coord, source_img):

    # calculate mean values on each channel of rgb scheme
    means = source_img[coord[1]:coord[3], coord[0]:coord[2]].mean(axis=(0,1))

    # calculate 3d distance squared between chromosome and mean values
    score = 0.0
    for i in range(len(chromosome)):
        score += (chromosome[i] - means[i]) * (chromosome[i] - means[i])
    
    # return fitness score
    return 1 / (1 + score)


def selection(population, probability):
    # calculate the sum of all probabilities
    total = 0.0
    for i in range(CHROMOSOMES_NUMBER):
        total += probability[i]

    # calculate the probability to be selected in next generation
    for i in range(CHROMOSOMES_NUMBER):
        probability[i] /= total

    # generate new array for population constructed from selected chromosomes
    new_population = [None] * CHROMOSOMES_NUMBER

    # calculate cumulative probability distribution
    cumulative_probability = [None] * CHROMOSOMES_NUMBER
    cumulative_probability[0] = probability[0]
    for i in range(1,CHROMOSOMES_NUMBER):
        cumulative_probability[i] = probability[i] + cumulative_probability[i-1]

    # select the chromosomes according to cumulative probability distribution
    for i in range(CHROMOSOMES_NUMBER):
        r = random.uniform(0,1)
        for j in range(CHROMOSOMES_NUMBER):
            if j == 0:
                if 0 <= r and r < cumulative_probability[j]:
                    new_population[i] = population[j].copy()
            else:
                if cumulative_probability[j-1] <= r and r < cumulative_probability[j]:
                    new_population[i] = population[j].copy()

    return new_population


def crossover(population):

    # generate new array for population with CROSSOVER_RATE of crossovered mates
    # new_population = population.copy()
    
    # array for parents that will be crossovered
    parents = []
    for i in range(CHROMOSOMES_NUMBER):
        r = random.uniform(0,1)
        if r < CROSSOVER_RATE:
            parents.append(i)

    # apply one-cut technique of crossover on chosen parents
    # all other chromosomes are staying the same as before
    for i in range(len(parents)):
        cut = random.randint(1,3)
        for k in range(cut, len(population[parents[i]])):
            population[parents[i]][k] = population[parents[(i + 1)%(i + 1)]][k]

    return population


def mutation(population):

    # produce mutation of chromosomes with MUTATION_RATE probability
    for chromosome in population:
        for move in range(len(chromosome)):
            r = random.uniform(0, 1)
            if r < MUTATION_RATE:
                chromosome[move] = random.randint(0,256)

    return population


def getChromosome(coord, source_img):

    # generate population of chromosomes
    population = [[random.randint(0,256), random.randint(0,256), random.randint(0,256)].copy() for i in range(CHROMOSOMES_NUMBER)]
    # generate an array which will store current fitness score for corresponding chromosome
    score = [None] * CHROMOSOMES_NUMBER
    
    # set the best score to the worst outcome
    best_score = 0.0

    # run the evolution process until score of the best chromocome will be more that 0.1
    while(best_score < 0.1):

        # calculate the fitness score for each chromosome and 
        # find out which has the best score, save it and it's score
        for i in range(CHROMOSOMES_NUMBER):
            score[i] = fitness(population[i], coord, source_img)
            if score[i] > best_score:
                best_score = score[i]
                best_chromosome = population[i]
        
        # run the selection procedure
        population = selection(population, score)
        # run the crossover procedure
        population = crossover(population)
        # run the mutation procedure
        population = mutation(population)

    return best_chromosome


if __name__ == "__main__":

    # start timing
    start_time = time.time()

    # read the image
    image = cv2.imread('./img/warrior.png')
    # convert to rgb schema, because by default it is bgr
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # add some pixels by reflecting the image to make it divisible by squares of pixels with GRID_SIZE
    height, width, _ = image.shape
    height_offset = ceil(height / GRID_SIZE) * GRID_SIZE - height
    width_offset = ceil(width / GRID_SIZE) * GRID_SIZE - width
    image = cv2.copyMakeBorder(image, 0, height_offset, 0, width_offset, cv2.BORDER_REFLECT)
    height, width, _ = image.shape

    # our future image generated by GA
    im = Image.new('RGB', (width, height), 'black')
    draw = ImageDraw.Draw(im)

    # idea how to divide into grids was taken from here 
    # https://answers.opencv.org/question/173852/how-to-split-image-into-small-blocks-process-on-them-and-then-join-all-the-blocks-together-again/?answer=173860#post-id-173860
    for y in range(0, height, GRID_SIZE):
        for x in range(0, width, GRID_SIZE):
            # find the best chromosome for square with coordinates (x,y) and (x + GRID_SIZE, y + GRID_SIZE)  
            solution = getChromosome((x, y, x + GRID_SIZE, y + GRID_SIZE), image)
            # draw that the most appropriate chromosome on the image with form of circle
            draw.ellipse((x, y, x + GRID_SIZE, y + GRID_SIZE), fill=(solution[0], solution[1], solution[2]))

    # end timing and print it to the console
    print(f'--- {time.time() - start_time} seconds ---')

    # show the generated image
    plt.imshow(im)
    plt.show()
    # save the image
    im.save('./img/catresult.png')     
