import cv2
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw
from math import ceil
import random
import time

start_time = time.time()

def score(solution, source_img):
    coord = solution[0]
    means = source_img[coord[1]:coord[3], coord[0]:coord[2]].mean(axis=(0,1)) 
    score = (solution[1]-means[0])*(solution[1]-means[0])+(solution[2]-means[1])*(solution[2]-means[1])+(solution[3]-means[2])*(solution[3]-means[2])
    
    return score

def mutation(solution):
    chance_of_mutation = 50
    
    for move in range(1, len(solution)):
        current_chance_of_mutation = random.randint(0,255)
        solution[move] = random.randint(0,255) if current_chance_of_mutation > chance_of_mutation else solution[move]

    return solution

def generate(gene, source_img):
    population = [gene.copy() for i in range(1000)]

    while(score(population[0], source_img) > 10):
        best_solution_score = score(population[0], source_img)
        best_solution = population[0].copy()

        for solution in range(0, len(population)):
            cur = score(population[solution], source_img)
            if cur < best_solution_score:
                best_solution_score = cur
                best_solution = population[solution]

        population = [mutation(best_solution.copy()) for solution in population]
        population[0] = best_solution.copy()

    return population[0].copy()


GRID_SIZE = 10

# read the image
image = cv2.imread('./img/dragon.jpg')
# convert to rgb schema, because by default it is bgr
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# add some pixels by reflecting the image to make it divisible by squares of pixels with GRID_SIZE
height, width, _ = image.shape
height_offset = ceil(height / GRID_SIZE) * GRID_SIZE - height
width_offset = ceil(width / GRID_SIZE) * GRID_SIZE - width
image = cv2.copyMakeBorder(image, 0, height_offset, 0, width_offset, cv2.BORDER_REFLECT)
height, width, _ = image.shape

# our future image generated by GA
im = Image.new('RGBA', (width, height), 'black')
draw = ImageDraw.Draw(im)

solutions = []

# idea how to divide into grids was taken from here 
# https://answers.opencv.org/question/173852/how-to-split-image-into-small-blocks-process-on-them-and-then-join-all-the-blocks-together-again/?answer=173860#post-id-173860
for y in range(0, height, GRID_SIZE):
    for x in range(0, width, GRID_SIZE):
        solution = generate([(x, y, x + GRID_SIZE, y + GRID_SIZE), 0, 0, 0], image)
        solutions.append(solution)
        draw.rectangle(solution[0], fill=(solution[1], solution[2], solution[3], 255))

im = im.convert('RGB')
print(f'--- {time.time() - start_time} seconds ---')

plt.imshow(im)
plt.show()  
im.save('./img/result.jpg')     
